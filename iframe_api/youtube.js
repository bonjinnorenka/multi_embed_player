//Notice! This file JSDOC is generated by cloude 3.5 sonnet and github copilot
// So some of the comments may include wrong
// Please refer to documents https://multi-embed-player.pages.dev/docs/reference/iframe_class/#mep_youtube

/**
 * @typedef {Object} mep_youtube_load_object
 * @property {string} videoId - The ID of the video.
 * @property {number} [startSeconds] - The start time of the video.
 * @property {number} [endSeconds] - The end time of the video.
 */

/**
 * @typedef {Object} mep_youtube_playerVars
 * @property {number} [autoplay] - Whether to autoplay the initial video.
 * @property {number} [startSeconds] - The start time of the video.
 * @property {number} [endSeconds] - The end time of the video.
 */

/**
 * @typedef {Object} mep_youtube_content
 * @property {string} id - The ID of the video.
 * @property {mep_youtube_playerVars} [playerVars] - Player parameters.
 * @property {number} width - The width of the video player.
 * @property {number} height - The height of the video player.
 */

/**
 * Class representing a YouTube player.
 */
class mep_youtube{
    static youtube_api_loaded = 0;
    static youtube_api_promise = [];

    /**
     * Load YouTube Iframe API asynchronously.
     * @returns {Promise} Promise that resolves when the API is loaded.
     */
    async #load_youtube_api(){
        return new Promise(async(resolve,reject)=>{
            if(mep_youtube.youtube_api_loaded===0){
                mep_youtube.youtube_api_loaded = 1;
                const script_doc = document.createElement("script");
                script_doc.src = "https://www.youtube.com/iframe_api";
                //script_doc.addEventListener("error",this.#dispatchEvent(new CustomEvent("onError",{detail:{code:1001}})));
                script_doc.addEventListener("load",()=>{YT.ready(()=>{mep_youtube.youtube_api_promise.forEach(func=>func());mep_youtube.youtube_api_loaded = 2;resolve()})});
                document.body.appendChild(script_doc);
            }
            else if(mep_youtube.youtube_api_loaded==1){
                mep_youtube.youtube_api_promise.push(resolve);
            }
            else{
                resolve();
            }
        });
    }

    /**
     * Create a new YouTube player instance.
     * @param {string|HTMLElement} replacing_element - The element to replace with the player.
     * @param {mep_youtube_content} content - The content options for the player.
     * @param {function} [player_set_event_function] - Function to set events on the player.
     */
    constructor(replacing_element,content,player_set_event_function){
        this.#load(replacing_element,content,player_set_event_function);
    }

    /**
     * Load the YouTube player.
     * @param {string|HTMLElement} replacing_element - The element to replace with the player or the ID of the element.
     * @param {mep_youtube_content} content - The content options for the player.
     * @param {function} [player_set_event_function] - Function to set events on the player.
     */
    async #load(replacing_element,content,player_set_event_function){
        this.player = document.createElement("div");//dummy
        if(typeof player_set_event_function === "function"){
            player_set_event_function(this.player);
        }
        await this.#load_youtube_api();
        let iframe_replace_node = replacing_element;
        if(typeof replacing_element==="string"){
            iframe_replace_node = document.getElementById(replacing_element);
        }
        const playerVars = content.playerVars || {};
        let playerVars_pass_over = {};
        this.autoplay = 0;
        if(playerVars.autoplay){
            this.autoplay = 1;
            playerVars_pass_over.autoplay = 1;
        }
        else{
            playerVars_pass_over.autoplay = 0;
        }
        this.startSeconds = 0;
        this.endSeconds = -1;
        if(playerVars.startSeconds){
            this.startSeconds = playerVars.startSeconds;
            playerVars_pass_over.start = playerVars.startSeconds;
        }
        if(playerVars.endSeconds){
            this.endSeconds = playerVars.endSeconds;
            playerVars_pass_over.end = playerVars.endSeconds;
        }
        this.el = iframe_replace_node;
        this.YT_player = new YT.Player(iframe_replace_node,{
            height: "315",
            width: "560",
            videoId: content.videoId,
            playerVars: playerVars_pass_over,
            host: "https://www.youtube-nocookie.com",
        });
        if(!this.autoplay){
            this.player.addEventListener("onReady",()=>{this.pauseVideo()},{once: true});
        }
        this.player.addEventListener("onReady",()=>{this.player.dispatchEvent(new Event("onReady"))});
        this.player.addEventListener("onError",(e)=>{this.#error_event_handler(e)});
        this.player.addEventListener("onStateChange",()=>{this.player.dispatchEvent(new CustomEvent("onStateChange",{detail:this.getPlayerState()}))});
        this.player.addEventListener("onStateChange",async()=>{if(await this.getCurrentTime()>this.getDuration()-1||(this.endSeconds!=-1&&await this.getCurrentTime()!=0&&this.endSeconds-1<=await this.getCurrentTime())){this.player.dispatchEvent(new Event("onEndVideo"))}})
    }

    /**
     * Handle error events from the player.
     * @param {Object} event - The error event. Event or CustomEvent.
     */
    #error_event_handler(event){
        //change status code to mep error code
        let code = 520;
        switch(event.data){
            case 2:
                code = 401;
                break;
            case 5:
                code = 500;
                break;
            case 100:
                code = 404;
                break;
            case 101:
            case 150:
                code = 403;
                break;
        }
        this.player.dispatchEvent(new CustomEvent("onError",{detail:{code:code}}));
    }

     /**
     * Play the video.
     */
    playVideo(){
        this.YT_player.playVideo();
    }

    /**
     * Pause the video.
     */
    pauseVideo(){
        this.YT_player.pauseVideo();
    }

    /**
     * Get the current time of the video.
     * @returns {number} The current time in seconds.
     */
    getCurrentTime(){
        return this.YT_player.getCurrentTime();
    }

    /**
     * Get the duration of the video.
     * @returns {number} The duration in seconds.
     */
    getDuration(){
        return this.YT_player.getDuration();
    }

    /**
     * Get the actual duration between the start and end times.
     * @returns {number} The actual duration in seconds.
     */
    getRealDulation(){
        if(this.endSeconds==-1){
            return this.getDuration() - this.startSeconds;
        }
        else{
            return this.endSeconds - this.startSeconds;
        }
    }

    /**
     * Seek to a specific time in the video.
     * @param {number} time - The time to seek to in seconds.
     */
    seekTo(time){
        if(typeof time==="number"){
            if(time<0){
                time = 0;
            }
            this.YT_player.seekTo(time);
        }
        else{
            console.error("time is not a number");
        }
    }

    /**
     * Set the volume of the player.
     * @param {number} volume - The volume level (0-100).
     */
    setVolume(volume){
        if(typeof volume==="number"&&volume>=0&&volume<=100){
            this.YT_player.setVolume(volume);
        }
        else{
            console.error("volume is not a number or not in range 0-100");
        }
    }

    /**
     * Mute the player.
     */
    mute(){
        this.YT_player.mute();
    }

     /**
     * Unmute the player.
     */
    unMute(){
        this.YT_player.unMute();
    }

    /**
     * Check if the player is muted.
     * @returns {boolean} Whether the player is muted.
     */
    isMuted(){
        return this.YT_player.isMuted();
    }

    /**
     * Get the current volume of the player.
     * @returns {number} The current volume level (0-100).
     */
    getVolume(){
        return this.YT_player.getVolume();
    }

    /**
     * Get the current state of the player.
     * @returns {number} The player state.
     */
    getPlayerState(){
        let nowstatus = this.YT_player.getPlayerState();
        if((this.getCurrentTime()>this.getDuration()-1&&this.getCurrentTime()!=0&&this.getDuration()!=0)||(this.endSeconds!=-1&&this.endSeconds-1<=this.getCurrentTime())){
            return 4
        }
        else if(nowstatus==-1){
            return 0
        }
        else if(nowstatus==0){
            return 4
        }
        else if(nowstatus==1){
            return 2
        }
        else if(nowstatus==2){
            return 3
        }
        else if(nowstatus==3||nowstatus==5){
            return 1
        }
    }

    /**
     * Get the title of the currently loaded video.
     * @returns {string} The video title.
     */
    getTitle(){
        return this.YT_player.getVideoData().title;
    }

    /**
     * Load a new video by ID.
     * @param {mep_youtube_load_object|string} content - The video content or ID.
     * @param {number} [startSeconds] - The start time of the video.
     */
    loadVideoById(content,startSeconds){
        if(typeof content==="object"){
            this.YT_player.loadVideoById(content);
        }
        else{
            this.YT_player.loadVideoById(content,startSeconds);
        }
    }

    /**
     * Cue a new video by ID.
     * @param {mep_youtube_load_object|string} content - The video content or ID.
     * @param {number} [startSeconds] - The start time of the video.
     */
    cueVideoById(content,startSeconds){
        if(typeof content==="object"){
            this.YT_player.cueVideoById(content);
        }
        else{
            this.YT_player.cueVideoById(content,startSeconds);
        }
    }

    /**
     * Dispatch an event on the player.
     * @param {Event} event - The event to dispatch.
     */
    #dispatchEvent(event){
        try{
            this.player.dispatchEvent(event);
        }
        catch(e){
            console.error(e);
        }
    }
}